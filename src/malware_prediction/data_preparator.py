import gc
import math

import pandas as pd

from mpi4py import MPI

class DataPreparator:

    def __init__(self):
        # LOAD AND FREQUENCY-ENCODE
        self._FE = ['EngineVersion', 'AppVersion', 'AvSigVersion', 'Census_OSVersion']
        # LOAD AND ONE-HOT-ENCODE
        self._OHE = ['RtpStateBitfield', 'IsSxsPassiveMode', 'DefaultBrowsersIdentifier',
                     'AVProductStatesIdentifier', 'AVProductsInstalled', 'AVProductsEnabled',
                     'CountryIdentifier', 'CityIdentifier',
                     'GeoNameIdentifier', 'LocaleEnglishNameIdentifier',
                     'Processor', 'OsBuild', 'OsSuite',
                     'SmartScreen', 'Census_MDC2FormFactor',
                     'Census_OEMNameIdentifier',
                     'Census_ProcessorCoreCount',
                     'Census_ProcessorModelIdentifier',
                     'Census_PrimaryDiskTotalCapacity', 'Census_PrimaryDiskTypeName',
                     'Census_HasOpticalDiskDrive',
                     'Census_TotalPhysicalRAM', 'Census_ChassisTypeName',
                     'Census_InternalPrimaryDiagonalDisplaySizeInInches',
                     'Census_InternalPrimaryDisplayResolutionHorizontal',
                     'Census_InternalPrimaryDisplayResolutionVertical',
                     'Census_PowerPlatformRoleName', 'Census_InternalBatteryType',
                     'Census_InternalBatteryNumberOfCharges',
                     'Census_OSEdition', 'Census_OSInstallLanguageIdentifier',
                     'Census_GenuineStateName', 'Census_ActivationChannel',
                     'Census_FirmwareManufacturerIdentifier',
                     'Census_IsTouchEnabled', 'Census_IsPenCapable',
                     'Census_IsAlwaysOnAlwaysConnectedCapable', 'Wdft_IsGamer',
                     'Wdft_RegionIdentifier']

    def import_data(self, nrows, offset=0, use_fe=True, use_ohe=True):
        # LOAD ALL AS CATEGORIES
        dtypes = {}
        if use_fe:
            for x in self._FE: dtypes[x] = 'category'
        if use_ohe:
            for x in self._OHE: dtypes[x] = 'category'
        dtypes['MachineIdentifier'] = 'str'
        dtypes['HasDetections'] = 'int8'

        # LOAD CSV FILE
        return pd.read_csv('./data/train.csv', usecols=dtypes.keys(), dtype=dtypes, nrows=nrows, skiprows=[offset])

    def encode_data(self, df, use_fe=True, use_ohe=True):
        cols = []
        dd = []
        comm = MPI.COMM_WORLD
        size = comm.Get_size()
        rank = comm.Get_rank()

        # ENCODE NEW
        if use_fe:
            for x in self._FE:
                cols += self._encode_FE(df, x, comm, rank, size)
            for x in self._FE:
                del df[x]
        if use_ohe:
            for x in self._OHE:
                tmp = self._encode_OHE(df, x, 0.005, 5, comm, rank, size)
                cols += tmp[0]
                dd.append(tmp[1])
            for x in self._OHE:
                del df[x]

        x = gc.collect()
        return cols, dd

    # CHECK FOR NAN
    @staticmethod
    def _check_nan(x):
        if isinstance(x, float):
            if math.isnan(x):
                return True
        return False

    def _get_mean(self, df, x, col, tar, comm, size):
        if self._check_nan(x):
            return comm.allreduce(df[df[col].isna()][tar].mean(), op=MPI.SUM) / size
        else:
            return comm.allreduce(df[df[col] == x][tar].mean()) / size

    # FREQUENCY ENCODING
    @staticmethod
    def _encode_FE(df, col, comm, rank, size):

        d = df[col].value_counts(dropna=False)
        data_gather = comm.gather(d, root=0)
        if rank == 0:
            for i in range(1, size):
                d = d.add(data_gather[i], fill_value=0)
        else:
            assert data_gather is None
        d = comm.bcast(d, root=0)

        n = col + "_FE"
        df[n] = df[col].map(d).astype('int64') / d.max()
        return [n]

    # ONE-HOT-ENCODE ALL CATEGORY VALUES THAT COMPRISE MORE THAN
    # "FILTER" PERCENT OF TOTAL DATA AND HAS SIGNIFICANCE GREATER THAN "ZVALUE"
    def _encode_OHE(self, df, col, filter, zvalue, comm, rank, size, tar='HasDetections', m=0.5):

        cv = df[col].value_counts(dropna=False)
        cv_gather = comm.gather(cv, root=0)
        if rank == 0:
            for i in range(1, size):
                cv = cv.add(cv_gather[i], fill_value=0)
        else:
            assert cv_gather is None
        cv = comm.bcast(cv, root=0)
        cvd = cv.to_dict()
        length = cv[:].sum()
        th = filter * length
        sd = zvalue * 0.5 / math.sqrt(th)
        n = []
        d = {}
        for x in cv.index:
            try:
                if cv[x] < th: break
                sd = zvalue * 0.5 / math.sqrt(cv[x])
            except:
                if cvd[x] < th: break
                sd = zvalue * 0.5 / math.sqrt(cvd[x])

            r = self._get_mean(df, x, col, tar, comm, size)

            if abs(r - m) > sd:
                nm = col + '_BE_' + str(x)
                if self._check_nan(x):
                    df[nm] = (df[col].isna()).astype('int8')
                else:
                    df[nm] = (df[col] == x).astype('int8')
                n.append(nm)
                d[x] = 1
        return [n, d]
