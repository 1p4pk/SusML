import gc
import math

import pandas as pd


class DataPreparator:

    def __init__(self):
        # LOAD AND FREQUENCY-ENCODE
        self._FE = ['EngineVersion', 'AppVersion', 'AvSigVersion', 'Census_OSVersion']
        # LOAD AND ONE-HOT-ENCODE
        self._OHE = ['RtpStateBitfield', 'IsSxsPassiveMode', 'DefaultBrowsersIdentifier',
                     'AVProductStatesIdentifier', 'AVProductsInstalled', 'AVProductsEnabled',
                     'CountryIdentifier', 'CityIdentifier',
                     'GeoNameIdentifier', 'LocaleEnglishNameIdentifier',
                     'Processor', 'OsBuild', 'OsSuite',
                     'SmartScreen', 'Census_MDC2FormFactor',
                     'Census_OEMNameIdentifier',
                     'Census_ProcessorCoreCount',
                     'Census_ProcessorModelIdentifier',
                     'Census_PrimaryDiskTotalCapacity', 'Census_PrimaryDiskTypeName',
                     'Census_HasOpticalDiskDrive',
                     'Census_TotalPhysicalRAM', 'Census_ChassisTypeName',
                     'Census_InternalPrimaryDiagonalDisplaySizeInInches',
                     'Census_InternalPrimaryDisplayResolutionHorizontal',
                     'Census_InternalPrimaryDisplayResolutionVertical',
                     'Census_PowerPlatformRoleName', 'Census_InternalBatteryType',
                     'Census_InternalBatteryNumberOfCharges',
                     'Census_OSEdition', 'Census_OSInstallLanguageIdentifier',
                     'Census_GenuineStateName', 'Census_ActivationChannel',
                     'Census_FirmwareManufacturerIdentifier',
                     'Census_IsTouchEnabled', 'Census_IsPenCapable',
                     'Census_IsAlwaysOnAlwaysConnectedCapable', 'Wdft_IsGamer',
                     'Wdft_RegionIdentifier']

    def import_data(self, nrows, offset=0, use_fe=True, use_ohe=True):
        # LOAD ALL AS CATEGORIES
        dtypes = {}
        if use_fe:
            for x in self._FE: dtypes[x] = 'category'
        if use_ohe:
            for x in self._OHE: dtypes[x] = 'category'
        dtypes['MachineIdentifier'] = 'str'
        dtypes['HasDetections'] = 'int8'

        # LOAD CSV FILE
        return pd.read_csv('./data/train.csv', usecols=dtypes.keys(), dtype=dtypes, nrows=nrows, skiprows=[offset])

    def encode_data(self, df, use_fe=True, use_ohe=True):
        cols = []
        dd = []

        # ENCODE NEW
        if use_fe:
            for x in self._FE:
                cols += self._encode_FE(df, x)
            for x in self._FE:
                del df[x]
        if use_ohe:
            for x in self._OHE:
                tmp = self._encode_OHE(df, x, 0.005, 5)
                cols += tmp[0];
                dd.append(tmp[1])
            for x in self._OHE:
                del df[x]

        x = gc.collect()
        return cols, dd

    # CHECK FOR NAN
    @staticmethod
    def _check_nan(x):
        if isinstance(x, float):
            if math.isnan(x):
                return True
        return False

    # FREQUENCY ENCODING
    @staticmethod
    def _encode_FE(df, col):
        d = df[col].value_counts(dropna=False)
        n = col + "_FE"
        df[n] = df[col].map(d) / d.max()
        return [n]

    # ONE-HOT-ENCODE ALL CATEGORY VALUES THAT COMPRISE MORE THAN
    # "FILTER" PERCENT OF TOTAL DATA AND HAS SIGNIFICANCE GREATER THAN "ZVALUE"
    def _encode_OHE(self, df, col, filter, zvalue, tar='HasDetections', m=0.5):
        cv = df[col].value_counts(dropna=False)
        cvd = cv.to_dict()
        th = filter * len(df)
        sd = zvalue * 0.5 / math.sqrt(th)
        n = []
        d = {}
        for x in cv.index:
            try:
                if cv[x] < th: break
                sd = zvalue * 0.5 / math.sqrt(cv[x])
            except:
                if cvd[x] < th: break
                sd = zvalue * 0.5 / math.sqrt(cvd[x])
            if self._check_nan(x):
                r = df[df[col].isna()][tar].mean()
            else:
                r = df[df[col] == x][tar].mean()
            if abs(r - m) > sd:
                nm = col + '_BE_' + str(x)
                if self._check_nan(x):
                    df[nm] = (df[col].isna()).astype('int8')
                else:
                    df[nm] = (df[col] == x).astype('int8')
                n.append(nm)
                d[x] = 1
        return [n, d]
