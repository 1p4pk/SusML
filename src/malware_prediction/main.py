import os
import socket
import sys
import pandas as pd
import torch
from torch.utils.data.dataloader import DataLoader

from dataset import MalwareDataset
from data_preparator import DataPreparator
from model import MalwarePredictor
from sklearn.model_selection import train_test_split
from torch import distributed as dist
from torch import nn
from torch import optim
from torch.nn.parallel import DistributedDataParallel as DDP

from model import MalwarePredictor
from train import ModelTrainer


DATA_PATH = "./data/train.csv"
ENCODED_DATA_PATH = "~/SusML/data/train_encoded_pi.csv"


def run_process():
    pass


def run_model():
    print("Data prepared.")
    dataset = MalwareDataset.load(ENCODED_DATA_PATH)
    loader = DataLoader(dataset)
    X_train = loader.dataset.X
    y_train = loader.dataset.y
    model = DDP(MalwarePredictor(len(loader.dataset.cols), 100, 100, 1))
    loss = nn.MSELoss()
    optimizer = optim.SGD(model.parameters(), lr=0.01)
    print("Model prepared.")
    print("Process group initialized.")
    trainer = ModelTrainer(model, loss, optimizer)
    print("Trainer initialized.")
    trainer.train(20, X_train, y_train, verbose=True)
    print("Done training.")
    dist.destroy_process_group()

    # run_eval(model, X_test, y_test)


def run_eval(model, X_test, y_test):
    model.eval()

    preds = []

    with torch.no_grad():
        for val in X_test:
            y_hat = model.forward(val)
            preds.append(y_hat.argmax().item())

    df = pd.DataFrame({'Y': y_test, 'YHat': preds})
    df['Correct'] = [1 if corr == pred else 0 for corr,
                     pred in zip(df['Y'], df['YHat'])]
    print(df['Correct'].sum() / len(df))


def init_processes(fn, backend='mpi'):
    """ Initialize the distributed environment. """
    world_size = int(os.environ['OMPI_COMM_WORLD_SIZE'])
    world_rank = int(os.environ['OMPI_COMM_WORLD_RANK'])
    hostname = socket.gethostname()
    print(f"Running rank {world_rank} of {world_size} on {hostname}")
    dist.init_process_group(backend)
    fn()


if __name__ == '__main__':
    dispatcher = {
        'run_process': run_process,
        'run_model': run_model
    }
    try:
        function = dispatcher[sys.argv[1]]
        init_processes(function, backend='mpi')
    except KeyError:
        raise ValueError(
            f"""You entered {sys.argv[1]}, which is an invalid input. 
            Enter run_process or run_model as input parameter.""")
