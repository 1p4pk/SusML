import os
import socket
import time
from concurrent.futures import ThreadPoolExecutor
from time import sleep

import psutil

pid = os.getpid()
py = psutil.Process(pid)
HOSTNAME = socket.gethostname()
MESSAGE = """
            --- {hostname} ---
            
                {function}

                {row_num}     

            --- {run_time} S ---"""


def timeit(save_path="", row_count=0):
    def inner(function):
        def wrapper(*args, **kwargs):
            start_time = time.time()
            result = function(*args, **kwargs)
            run_time = round(time.time() - start_time, 2)
            if save_path is not "":
                with open(save_path, "a") as eval_file:
                    eval_file.writelines(f"{HOSTNAME}, {row_count}, {run_time}\n")
            print(MESSAGE.format(hostname=HOSTNAME, function=function.__name__, row_num=row_count, run_time=run_time))
            return result

        return wrapper

    return inner


class _MemoryMonitor:
    def __init__(self, update_rate=0.1):
        self.update_rate = update_rate
        self.keep_measuring = True

    def measure_usage(self):
        max_usage = 0
        while self.keep_measuring:
            usage = py.memory_info().rss
            max_usage = max(
                max_usage,
                usage
            )
            usage_mb = usage / 10 ** 6
            print(f"{HOSTNAME} memory usage: {round(usage_mb, 2)} MB")
            sleep(self.update_rate)

        return round(max_usage, 2)


def memory_monitor(update_rate=0.1):
    def inner(function):
        def wrapper(*args, **kwargs):
            print("Memory update in seconds: ", update_rate)
            with ThreadPoolExecutor() as executor:
                monitor = _MemoryMonitor(update_rate)
                mem_thread = executor.submit(monitor.measure_usage)
                try:
                    fn_thread = executor.submit(function, *args, **kwargs)
                    result = fn_thread.result()
                finally:
                    monitor.keep_measuring = False
                    max_usage = mem_thread.result()
            usage_mb = max_usage / 10 ** 6
            print(f"Peak memory usage of host {HOSTNAME}: {round(usage_mb, 2)} MB")
            return result

        return wrapper

    return inner


class _CPUMonitor:
    def __init__(self, update_rate=0.1):
        self.update_rate = update_rate
        self.keep_measuring = True

    def measure_usage(self):
        max_usage = 0
        while self.keep_measuring:
            usage = py.cpu_percent()
            max_usage = max(
                max_usage,
                usage
            )
            print(f"{HOSTNAME} CPU usage: {usage}%")
            sleep(self.update_rate)

        return max_usage


def cpu_monitor(update_rate=0.1):
    def inner(function):
        def wrapper(*args, **kwargs):
            print("CPU update in seconds: ", update_rate)
            with ThreadPoolExecutor() as executor:
                monitor = _CPUMonitor(update_rate)
                mem_thread = executor.submit(monitor.measure_usage)
                try:
                    fn_thread = executor.submit(function, *args, **kwargs)
                    result = fn_thread.result()
                finally:
                    monitor.keep_measuring = False
                    max_usage = mem_thread.result()
            print(f"Peak CPU usage of host {HOSTNAME}: {max_usage}%")
            return result

        return wrapper

    return inner
