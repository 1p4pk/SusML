import os
import socket
import sys
import time
from concurrent.futures import ThreadPoolExecutor
from time import sleep

import psutil

pid = os.getpid()
py = psutil.Process(pid)
UPDATE_RATE = 20
ROWS = int(sys.argv[1])
HOSTNAME = socket.gethostname()
MESSAGE = """
            --- {hostname} ---
            
                {function}

                {row_num}     

            --- {run_time} S ---"""


def timeit(file_name=""):
    def inner(function):
        def wrapper(*args, **kwargs):
            start_time = time.time()
            result = function(*args, **kwargs)
            run_time = round(time.time() - start_time, 2)
            if file_name != "":
                if file_name == "preprocessing":
                    save_path = f"./data/benchmark/run_time_{file_name}_{ROWS}.csv"
                    with open(save_path, "a") as runtime_file:
                        runtime_file.write(f"{HOSTNAME}, {ROWS}, {run_time}\n")
                else:
                    optimizer = sys.argv[2]
                    loss = sys.argv[3]
                    save_path = f"./data/benchmark/run_time_{file_name}_{optimizer}_{loss}_{ROWS}.csv"
                    with open(save_path, "a") as runtime_file:
                        runtime_file.write(f"{HOSTNAME}, {ROWS}, {run_time}\n")

            print(MESSAGE.format(hostname=HOSTNAME, function=function.__name__, row_num=ROWS, run_time=run_time))
            return result

        return wrapper

    return inner


class _MemoryMonitor:
    def __init__(self, update_rate=UPDATE_RATE, file_name=""):
        self.update_rate = update_rate
        self.file_name = file_name
        self.keep_measuring = True

    def measure_usage(self):
        if self.file_name == "":
            while self.keep_measuring:
                usage = round(py.memory_info().rss / 10 ** 6, 2)  # Memory usage in MB
                print(f"{HOSTNAME} memory usage: {usage} MB")
                sleep(self.update_rate)
        else:
            if self.file_name == "preprocessing":
                file = open(f"./data/benchmark/memory_usage_{self.file_name}_{ROWS}.csv", "a")
            else:
                optimizer = sys.argv[2]
                loss = sys.argv[3]
                save_path = f"./data/benchmark/memory_usage_{self.file_name}_{optimizer}_{loss}_{ROWS}.csv"
                file = open(save_path, "a")
            while self.keep_measuring:
                usage = round(py.memory_info().rss / 10 ** 6, 2)  # Memory usage in MB
                file.write(f"{HOSTNAME},{ROWS}, {usage}\n")
                sleep(self.update_rate)
            file.close()


def memory_monitor(update_rate=UPDATE_RATE, file_name=""):
    def inner(function):
        def wrapper(*args, **kwargs):
            print("Memory update in seconds: ", update_rate)
            with ThreadPoolExecutor() as executor:
                monitor = _MemoryMonitor(update_rate, file_name)
                mem_thread = executor.submit(monitor.measure_usage)
                try:
                    fn_thread = executor.submit(function, *args, **kwargs)
                    result = fn_thread.result()
                finally:
                    monitor.keep_measuring = False
                    mem_thread.result()
            return result

        return wrapper

    return inner


class _CPUMonitor:
    def __init__(self, update_rate=UPDATE_RATE, file_name=""):
        self.update_rate = update_rate
        self.file_name = file_name
        self.keep_measuring = True

    def measure_usage(self):
        if self.file_name == "":
            while self.keep_measuring:
                usage = py.cpu_percent()
                print(f"{HOSTNAME} CPU usage: {usage}%")
                sleep(self.update_rate)
        else:
            if self.file_name == "preprocessing":
                file = open(f"./data/benchmark/cpu_usage_{self.file_name}_{ROWS}.csv", "a")
            else:
                optimizer = sys.argv[2]
                loss = sys.argv[3]
                save_path = f"./data/benchmark/cpu_usage_{self.file_name}_{optimizer}_{loss}_{ROWS}.csv"
                file = open(save_path, "a")
            while self.keep_measuring:
                usage = py.cpu_percent()
                file.write(f"{HOSTNAME},{ROWS}, {usage}\n")
                sleep(self.update_rate)
            file.close()


def cpu_monitor(update_rate=UPDATE_RATE, file_name=""):
    def inner(function):
        def wrapper(*args, **kwargs):
            print("CPU update in seconds: ", update_rate)
            with ThreadPoolExecutor() as executor:
                monitor = _CPUMonitor(update_rate, file_name)
                mem_thread = executor.submit(monitor.measure_usage)
                try:
                    fn_thread = executor.submit(function, *args, **kwargs)
                    result = fn_thread.result()
                finally:
                    monitor.keep_measuring = False
                    mem_thread.result()
            return result

        return wrapper

    return inner
