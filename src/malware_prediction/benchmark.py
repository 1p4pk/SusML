import resource
import socket
import time
from concurrent.futures import ThreadPoolExecutor
from time import sleep

HOSTNAME = socket.gethostname()
MESSAGE = """
            --- {hostname} ---
            
                {function}

                {row_num}     

            --- {run_time} S ---"""


class _TimeIt:
    def __init__(self, f, save_path: str = "", row_count: int = 0):
        self.f = f
        self.save_path = save_path
        self.row_count = row_count

    def __call__(self, *args):
        start_time = time.time()
        self.f()
        run_time = round(time.time() - start_time, 2)
        if self.save_path is not "":
            with open(self.save_path, "a") as eval_file:
                eval_file.writelines(f"{HOSTNAME}, {self.row_count}, {run_time}\n")
        print(MESSAGE.format(hostname=HOSTNAME, function=self.f.__name__, row_num=self.row_count, run_time=run_time))


def timeit(function=None, save_path: str = "", row_count: int = 0):
    if function:
        return _TimeIt(function)
    else:
        def wrapper(function):
            return _TimeIt(function, save_path=save_path, row_count=row_count)

        return wrapper


class _MemoryMonitor:
    def __init__(self, function, update_rate=0.1):
        self.function = function
        self.update_rate = update_rate
        self.keep_measuring = True

    def __call__(self, *args):
        print("Memory update in seconds: ", self.update_rate)
        with ThreadPoolExecutor() as executor:
            monitor = _MemoryMonitor(self.function, self.update_rate)
            mem_thread = executor.submit(monitor.measure_usage)
            try:
                fn_thread = executor.submit(self.function)
                fn_thread.result()
            finally:
                monitor.keep_measuring = False
                max_usage = mem_thread.result()
        print(f"Peak memory usage of host {HOSTNAME}: {max_usage / 10 ** 3} MB")

    def measure_usage(self):
        max_usage = 0
        while self.keep_measuring:
            usage = resource.getrusage(resource.RUSAGE_SELF).ru_maxrss
            max_usage = max(
                max_usage,
                resource.getrusage(resource.RUSAGE_SELF).ru_maxrss
            )
            print(f"{HOSTNAME} memory usage: {usage / 10 ** 3} MB")
            sleep(self.update_rate)

        return max_usage


def memory_monitor(function=None, update_rate=0.1):
    if function:
        return _MemoryMonitor(function)
    else:
        def wrapper(function):
            return _MemoryMonitor(function, update_rate=update_rate)

        return wrapper
