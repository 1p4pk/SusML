import os
import socket
import sys
import time
from concurrent.futures import ThreadPoolExecutor
from datetime import datetime
from time import sleep
from typing import IO

import psutil

pid = os.getpid()
py = psutil.Process(pid)
UPDATE_RATE = 20
ROWS = int(sys.argv[1])
HOSTNAME = socket.gethostname()
MESSAGE = """
            --- {hostname} ---
            
                {function}

                {row_num}     

            --- {run_time} S ---"""


def timeit(file_name=""):
    def inner(function):
        def wrapper(*args, **kwargs):
            start_time = time.time()
            result = function(*args, **kwargs)
            run_time = round(time.time() - start_time, 2)
            timestamp = datetime.now()
            if file_name != "":
                if file_name == "preprocessing":
                    save_path = f"./data/benchmark/run_time_{file_name}_{ROWS}.csv"
                    with open(save_path, "a") as runtime_file:
                        runtime_file.write(f"{HOSTNAME}, {ROWS}, {run_time}, {timestamp}\n")
                else:
                    optimizer = sys.argv[2]
                    loss = sys.argv[3]
                    save_path = f"./data/benchmark/run_time_{file_name}_{optimizer}_{loss}_{ROWS}.csv"
                    with open(save_path, "a") as eval_file:
                        eval_file.write(f"{HOSTNAME}, {ROWS}, {run_time}, {timestamp}\n")
            print(MESSAGE.format(hostname=HOSTNAME, function=function.__name__, row_num=ROWS, run_time=run_time))
            return result

        return wrapper

    return inner


class _MemoryMonitor:
    def __init__(self, update_rate=UPDATE_RATE, file_name=""):
        self.update_rate = update_rate
        self.file_name = file_name
        self.keep_measuring = True

    def measure_usage(self):
        if self.file_name == "":
            while self.keep_measuring:
                usage_in_bytes = py.memory_info().rss
                print(f"{HOSTNAME} memory usage: {usage_in_bytes} MB")
                sleep(self.update_rate)
        else:
            file = self.__create_file("memory_usage")
            while self.keep_measuring:
                timestamp = datetime.now()
                usage_in_bytes = py.memory_info().rss
                file.write(f"{HOSTNAME},{ROWS}, {usage_in_bytes}, {timestamp}\n")
                sleep(self.update_rate)
            file.close()

    def __create_file(self, metric: str) -> IO:
        if self.file_name == "preprocessing":
            file = open(f"./data/benchmark/{metric}_{self.file_name}_{ROWS}.csv", "a")
        else:
            optimizer = sys.argv[2]
            loss = sys.argv[3]
            save_path = f"./data/benchmark/{metric}_{self.file_name}_{optimizer}_{loss}_{ROWS}.csv"
            file = open(save_path, "a")
        return file


def memory_monitor(update_rate=UPDATE_RATE, file_name=""):
    def inner(function):
        def wrapper(*args, **kwargs):
            print("Memory update in seconds: ", update_rate)
            with ThreadPoolExecutor() as executor:
                monitor = _MemoryMonitor(update_rate, file_name)
                mem_thread = executor.submit(monitor.measure_usage)
                try:
                    fn_thread = executor.submit(function, *args, **kwargs)
                    result = fn_thread.result()
                finally:
                    monitor.keep_measuring = False
                    mem_thread.result()
            return result

        return wrapper

    return inner


class _CPUMonitor:
    def __init__(self, update_rate=UPDATE_RATE, file_name=""):
        self.update_rate = update_rate
        self.file_name = file_name
        self.keep_measuring = True

    def measure_usage(self):
        if self.file_name == "":
            while self.keep_measuring:
                usage = py.cpu_percent()
                print(f"{HOSTNAME} CPU usage: {usage}%")
                sleep(self.update_rate)
        else:
            file = self.__create_file("cpu_usage")
            while self.keep_measuring:
                timestamp = datetime.now()
                usage = py.cpu_percent()
                file.write(f"{HOSTNAME},{ROWS}, {usage}, {timestamp}\n")
                sleep(self.update_rate)
            file.close()

    def __create_file(self, category: str) -> IO:
        if self.file_name == "preprocessing":
            file = open(f"./data/benchmark/{category}_{self.file_name}_{ROWS}.csv", "a")
        else:
            optimizer = sys.argv[2]
            loss = sys.argv[3]
            save_path = f"./data/benchmark/{category}_{self.file_name}_{optimizer}_{loss}_{ROWS}.csv"
            file = open(save_path, "a")
        return file


def cpu_monitor(update_rate=UPDATE_RATE, file_name=""):
    def inner(function):
        def wrapper(*args, **kwargs):
            print("CPU update in seconds: ", update_rate)
            with ThreadPoolExecutor() as executor:
                monitor = _CPUMonitor(update_rate, file_name)
                mem_thread = executor.submit(monitor.measure_usage)
                try:
                    fn_thread = executor.submit(function, *args, **kwargs)
                    result = fn_thread.result()
                finally:
                    monitor.keep_measuring = False
                    mem_thread.result()
            return result

        return wrapper

    return inner


class _DiskMonitor:
    def __init__(self, update_rate=UPDATE_RATE, file_name=""):
        self.update_rate = update_rate
        self.file_name = file_name
        self.keep_measuring = True

    def measure_usage(self):
        if self.file_name == "":
            while self.keep_measuring:
                usage_read_bytes, usage_write_bytes = self.__disk_usage_percent()
                print(f"{HOSTNAME} disk read bytes: {usage_read_bytes}, disk write, bytes: {usage_write_bytes}")
                sleep(self.update_rate)
        else:
            file = self.__create_file("disk_usage")
            while self.keep_measuring:
                timestamp = datetime.now()
                usage_read_bytes, usage_write_bytes = self.__disk_usage_percent()
                file.write(f"{HOSTNAME},{ROWS}, {usage_read_bytes}, {usage_write_bytes}, {timestamp}\n")
                sleep(self.update_rate)
            file.close()

    @staticmethod
    def __disk_usage_percent():
        io_counters = py.io_counters()
        # disk_usage_process = io_counters[2] + io_counters[3]  # read_bytes + write_bytes
        # disk_io_counter = psutil.disk_io_counters()
        # disk_total = disk_io_counter[2] + disk_io_counter[3]
        # return disk_usage_process / disk_total * 100
        return io_counters[2], io_counters[3]  # read_bytes + write_bytes

    def __create_file(self, category: str) -> IO:
        if self.file_name == "preprocessing":
            file = open(f"./data/benchmark/{category}_{self.file_name}_{ROWS}.csv", "a")
        else:
            optimizer = sys.argv[2]
            loss = sys.argv[3]
            save_path = f"./data/benchmark/{category}_{self.file_name}_{optimizer}_{loss}_{ROWS}.csv"
            file = open(save_path, "a")
        return file


def disk_monitor(update_rate=UPDATE_RATE, file_name=""):
    def inner(function):
        def wrapper(*args, **kwargs):
            print("Disk usage update in seconds: ", update_rate)
            with ThreadPoolExecutor() as executor:
                monitor = _DiskMonitor(update_rate, file_name)
                mem_thread = executor.submit(monitor.measure_usage)
                try:
                    fn_thread = executor.submit(function, *args, **kwargs)
                    result = fn_thread.result()
                finally:
                    monitor.keep_measuring = False
                    mem_thread.result()
            return result

        return wrapper

    return inner
